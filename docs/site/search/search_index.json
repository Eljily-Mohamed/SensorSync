{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Project Homepage Welcome to Our Project Homepage Welcome to the documentation of our embedded system project, developed by students at the \u00c9cole Nationale d'Ing\u00e9nieurs de Brest (ENIB). Our project focuses on configuring and retrieving information from two sensors: a color sensor (I2C) and a temperature and humidity sensor. Project Overview In this project, we integrated two types of sensors to collect environmental data: Color Sensor (I2C) : This sensor detects the color of objects and communicates the data via the I2C protocol. Temperature and Humidity Sensor : This sensor measures ambient temperature and humidity levels. Sensors Used Grove - SHT40 Temperature and Humidity Sensor The Grove SHT40 digital sensor is based on Sensirion's industry-proven humidity and temperature sensors. It provides consistent temperature and humidity accuracy over a wide measurement range. Grove - TCS34725CS Color Sensor The TCS34725CS color sensor with digital I2C output is based on an 8x2 array of filtered photodiodes and 16-bit analog-to-digital converters. It measures the chromaticity of ambient light or objects. Among the 16 photodiodes, 4 have red filters, 4 have green filters, 4 have blue filters, and 4 have no filter (clear). The synchronization input pin allows precise synchronous conversion control using an external pulsed light source.","title":"Project Homepage"},{"location":"#project-homepage","text":"","title":"Project Homepage"},{"location":"#welcome-to-our-project-homepage","text":"Welcome to the documentation of our embedded system project, developed by students at the \u00c9cole Nationale d'Ing\u00e9nieurs de Brest (ENIB). Our project focuses on configuring and retrieving information from two sensors: a color sensor (I2C) and a temperature and humidity sensor.","title":"Welcome to Our Project Homepage"},{"location":"#project-overview","text":"In this project, we integrated two types of sensors to collect environmental data: Color Sensor (I2C) : This sensor detects the color of objects and communicates the data via the I2C protocol. Temperature and Humidity Sensor : This sensor measures ambient temperature and humidity levels.","title":"Project Overview"},{"location":"#sensors-used","text":"","title":"Sensors Used"},{"location":"#grove-sht40-temperature-and-humidity-sensor","text":"The Grove SHT40 digital sensor is based on Sensirion's industry-proven humidity and temperature sensors. It provides consistent temperature and humidity accuracy over a wide measurement range.","title":"Grove - SHT40 Temperature and Humidity Sensor"},{"location":"#grove-tcs34725cs-color-sensor","text":"The TCS34725CS color sensor with digital I2C output is based on an 8x2 array of filtered photodiodes and 16-bit analog-to-digital converters. It measures the chromaticity of ambient light or objects. Among the 16 photodiodes, 4 have red filters, 4 have green filters, 4 have blue filters, and 4 have no filter (clear). The synchronization input pin allows precise synchronous conversion control using an external pulsed light source.","title":"Grove - TCS34725CS Color Sensor"},{"location":"IHM/","text":"IHM System Overview This document provides an overview of the IHM (Interface Homme-Machine) system we built using Electron.js. The IHM is designed to interact with an STM32 microcontroller, facilitating data communication and display via a user-friendly interface. The system consists of a browser-side application built with React.js and Tailwind CSS, and a server-side application built with Node.js to manage the database and handle serial communication using Socket.io. Architecture The IHM system is composed of the following components: Browser-Side Application : Built with React.js and styled with Tailwind CSS. Server-Side Application : Built with Node.js, manages the database, and handles serial communication with the STM32 microcontroller. Electron.js : Wraps the browser-side application to create a cross-platform desktop application. Browser-Side Application Server-Side Application The server-side application is built using Node.js and handles the following tasks: Database Management : Manages the storage and retrieval of sensor data in a database (sqlite3). Serial Communication : Establishes communication with the STM32 microcontroller via a serial connection and processes the received data. Socket.io Integration : Integrates Socket.io to facilitate real-time communication with the browser-side application. Features User Interface : Provides a user-friendly interface to display temperature and humidity data received from the STM32 microcontroller. Real-Time Updates : Uses Socket.io to receive real-time data updates from the server and display them in the UI. Data Visualization : Displays the sensor data in a clear and visually appealing manner, using charts.","title":"IHM System Overview"},{"location":"IHM/#ihm-system-overview","text":"This document provides an overview of the IHM (Interface Homme-Machine) system we built using Electron.js. The IHM is designed to interact with an STM32 microcontroller, facilitating data communication and display via a user-friendly interface. The system consists of a browser-side application built with React.js and Tailwind CSS, and a server-side application built with Node.js to manage the database and handle serial communication using Socket.io.","title":"IHM System Overview"},{"location":"IHM/#architecture","text":"The IHM system is composed of the following components: Browser-Side Application : Built with React.js and styled with Tailwind CSS. Server-Side Application : Built with Node.js, manages the database, and handles serial communication with the STM32 microcontroller. Electron.js : Wraps the browser-side application to create a cross-platform desktop application.","title":"Architecture"},{"location":"IHM/#browser-side-application","text":"","title":"Browser-Side Application"},{"location":"IHM/#server-side-application","text":"The server-side application is built using Node.js and handles the following tasks: Database Management : Manages the storage and retrieval of sensor data in a database (sqlite3). Serial Communication : Establishes communication with the STM32 microcontroller via a serial connection and processes the received data. Socket.io Integration : Integrates Socket.io to facilitate real-time communication with the browser-side application.","title":"Server-Side Application"},{"location":"IHM/#features","text":"User Interface : Provides a user-friendly interface to display temperature and humidity data received from the STM32 microcontroller. Real-Time Updates : Uses Socket.io to receive real-time data updates from the server and display them in the UI. Data Visualization : Displays the sensor data in a clear and visually appealing manner, using charts.","title":"Features"},{"location":"SHT40_SENSOR/","text":"SHT40 SENSOR This section provides a detailed explanation of the embedded system aspect of our project, focusing specifically on the Grove SHT40 Temperature and Humidity Sensor. Hardware Components Microcontroller Development Kit We utilize an STM32 microcontroller development kit to build and debug code for our project. This development kit is provided by the ENIB internal pack used in our course (SDK pack), enabling efficient development and debugging of firmware for the embedded system. Software Implementation Before we can utilize the SHT40 sensor, it is crucial to establish communication with it using the I2C protocol and configure it with the appropriate settings. To achieve this, we need to implement basic functions that facilitate communication with the sensor. These functions serve as the foundation for all subsequent interactions with the sensor. Project Structure To integrate the SHT40 sensor into our project, you'll need to follow these steps: Create the necessary files: sht40.h : Header file for SHT40 sensor interface. sht40.c : Source file for SHT40 sensor implementation. Essential Functions for Sensor Communication To interact with the SHT40 sensor, we implement the following fundamental functions: sht4x_write(uint8_t reg, uint8_t value) : This function writes a single byte of data to a specified register of the sensor.. static int16_t sht4x_write(uint8_t reg, uint8_t value) { uint8_t data[2]; data[0] = reg; data[1] = value & 0xFF; return i2c_write(I2C1, SHT4X_ADDRESS, data, sizeof(data)); } read(uint8_t reg , int delay) : This function reads a single byte of data from a specified register of the sensor. static uint8_t sht4x_read(uint8_t reg, int delay) { uint8_t value; uint8_t reg_data[1] = {reg}; if (i2c_write(I2C1, SHT4X_ADDRESS, reg_data, 1) != I2C_OK) { uart_puts(_USART2, \"\\n\\rErreur lors de l'\u00e9criture dans le registre\\n\"); return 0; } delay_us(delay); if (i2c_read(I2C1, SHT4X_ADDRESS, &value, 1) != I2C_OK) { uart_puts(_USART2, \"\\n\\rErreur lors de la lecture d'octets\\n\"); return 0; } return value; } write_n(uint8_t reg, uint8_t* values, uint8_t length) : This function writes multiple bytes of data to consecutive registers of the sensor. static int16_t sht4x_write_n(uint8_t reg, uint8_t* values, uint8_t length) { uint8_t data[length + 1]; data[0] = reg; for (size_t i = 0; i < length; i++) { data[i + 1] = values[i]; } return i2c_write(I2C1, SHT4X_ADDRESS, data, sizeof(data)); } read_n(uint8_t reg, uint8_t* values, uint8_t length, int delay) : This function reads multiple bytes of data from consecutive registers of the sensor. void read_n(uint8_t reg, uint8_t* values, uint8_t length, int delay) { uint8_t reg_data[1] = {reg}; if (i2c_write(I2C1, SHT4X_ADDRESS, reg_data, 1) != I2C_OK) { uart_puts(_USART2,\"\\n\\rErreur lors de l'\u00e9criture dans le registre\\n\"); return I2C_ERROR; } delay_us(delay); if (i2c_read(I2C1, SHT4X_ADDRESS, values, length) != I2C_OK) { uart_puts(_USART2,\"\\n\\rErreur lors de la lecture d'octets\\n\"); return; } } sht4x_write_cmd(const uint8_t* cmd) : This function writes a command to the sensor. static int16_t sht4x_write_cmd(const uint8_t* cmd) { return i2c_write(I2C1, SHT4X_ADDRESS, cmd, 1); } sht4x_write_cmd(const uint8_t* cmd) : This function writes a command to the sensor. static int16_t sht4x_write_cmd(const uint8_t* cmd) { return i2c_write(I2C1, SHT4X_ADDRESS, cmd, 1); } These functions provide the necessary groundwork for interacting with the SHT40 sensor via the I2C protocol. Once implemented, we can proceed with initializing the sensor and configuring it according to our project requirements. Key Details about the SHT40 Sensor I2C Communication: Specification: Based on NXP\u2019s I2C-bus specification. Supported Modes: Standard, fast mode, and fast mode plus. Data Transfer: Transferred in multiples of 16-bit words with an 8-bit checksum (CRC). Addressing: 7-bit I2C address followed by an eighth bit, denoting communication direction. Documentation: SHT40 Documentation Data Type & Length: Operates with: 8-bit data packages. Checksum: Included after every second 8-bit data package. Transmission: Humidity and temperature data transmitted in a specific format. Checksum Calculation: For Read Transfers: Each 16-bit data is followed by a checksum using CRC-8 algorithm. Command Overview: Various Commands: Available for different operations like measuring temperature and humidity, reading serial number, etc. Refer to the documentation for detailed specifications and usage instructions. Sensor Initialization To use the SHT40 sensor, we need to initialize the I2C communication and configure the sensor. For initialization, we first read the serial number to ensure that the sensor is connected and functioning properly. The process involves detecting if a sensor is connected by reading the ID register. If the sensor does not respond or if the response is not the expected value, the test fails. /** * Detects if a sensor is connected by reading out the ID register. If the sensor does not answer * or if the answer is not the expected value, the test fails. * * @return 0 if a sensor was detected */ int16_t sht4x_probe(void); int16_t sht4x_probe(void) { uint32_t serial; return sht4x_read_serial(&serial); } // Internal function to retrieve the number of words divided by the word size (2 bytes) #define SENSIRION_WORD_SIZE 2 #define SENSIRION_NUM_WORDS(x) (sizeof(x) / SENSIRION_WORD_SIZE) // Duration necessary to write command #define SHT4X_CMD_DURATION_USEC int16_t sht4x_read_serial(uint32_t* serial) { const uint8_t cmd = SHT4X_CMD_READ_SERIAL; int16_t ret; uint16_t serial_words[SENSIRION_NUM_WORDS(*serial)]; ret = write_cmd(&sht4x_cmd_measure); if (ret) return ret; read_n((uint8_t*)serial_words,sizeof(serial_words)); *serial = ((uint32_t)serial_words[0] << 16) | serial_words[1]; return I2C_OK; } Task One After initialization, we can now retrieve the temperature and humidity data. To do this, we need to create a function that allows us to read the temperature and humidity. Below is the function we developed: int16_t sht4x_measure_blocking_read(float* temperature, float* humidity) { int16_t ret; ret = write_cmd(&sht4x_cmd_measure); if (ret) return ret; delay_us(sht4x_cmd_measure_delay_us); return sht4x_read_measurement(temperature, humidity); } Function Explanation To read the temperature, we start by writing a command. After this, we can read the data. Similar to other sensors where a register pointer is used, we first send a write header to the I2C slave followed by a command. For example, \"measure RH&T with highest precision.\" After the measurement is finished, the read request directed to the I2C slave will be acknowledged, and the transmission of data will be started by the slave. Here is an image explaining the process: After sending the command, we can read the temperature and humidity. We need to use a formula to convert each value correctly. Refer to the documentation SHT40 Documentation for more details. int16_t sht4x_read_measurement(float* temperature, float* humidity) { uint16_t rawTemp, rawHumd; uint16_t words[2]; int16_t ret = read_n(words,SENSIRION_NUM_WORDS(words)); if (ret) return ret; /** * formulas for conversion of the sensor signals, optimized for fixed point * algebra: * Temperature = 175 * S_T / 65535 - 45 * Relative Humidity = 125 * (S_RH / 65535) - 6 */ rawTemp = ((uint16_t) words[0] << 8) | words[1]; rawHumd = ((uint16_t) words[2] << 8) | words[3]; *temperature = (-45.0f + 175.0f * (rawTemp / 65535.0f)); *humidity = (-6.0f + 125.0f * (rawHumd / 65535.0f)); return ret; } Task Two Great, now we can test if this works well. We need to use serial UART ST-LINK to display the current temperature and humidity in the terminal. Here is a test where we define main.c. We will do the first test by adding some code to transform a float into two parts: the integer part and the decimal part. #include \"libshield/sht4x.h\" #define delay_us(us) timer_wait_us(_TIM3, us) static void on_command_received(char c) { command = c; } int main(void) { uart_init(_USART2, 115200, UART_8N1, on_command_received); i2c_master_init(_I2C1); while (sht4x_probe() != 0) { uart_printf(UART_TO_USE, \"SHT sensor probing failed\\n\"); delay_us(1000); // Sleep 1s } while (1) { float temperature, humidity; int8_t ret = sht4x_measure_blocking_read(&temperature, &humidity); if (ret == 0) { int temp_int = (int) temperature; float temp_frac = temperature - temp_int; int hum_int = (int) humidity; float hum_frac = humidity - hum_int; int temp_int_frac = (int)(temp_frac * 1000); int hum_int_frac = (int)(hum_frac * 1000); uart_printf(UART_TO_USE, \"\\r\\ntemperature: %d.%d C\", temp_int, temp_int_frac); uart_printf(UART_TO_USE, \"\\r\\nhumidity: %d.%d\", hum_int, hum_int_frac); delay_us(1000); // Sleep 1s } else { uart_printf(UART_TO_USE, \"\\r\\nError reading measurement\"); } break; } return 0; } Summary In this section, we include the essential details about the SHT40 sensor, its basic functionalities, and how to interface it with a microcontroller to read and display temperature and humidity values using UART. We also provide a sample code implementation for initializing the sensor, reading data, and handling errors. After this, we will add more extra features and improvements to enhance the functionality and reliability of the system.","title":"SHT40 SENSOR"},{"location":"SHT40_SENSOR/#sht40-sensor","text":"This section provides a detailed explanation of the embedded system aspect of our project, focusing specifically on the Grove SHT40 Temperature and Humidity Sensor.","title":"SHT40 SENSOR"},{"location":"SHT40_SENSOR/#hardware-components","text":"","title":"Hardware Components"},{"location":"SHT40_SENSOR/#microcontroller-development-kit","text":"We utilize an STM32 microcontroller development kit to build and debug code for our project. This development kit is provided by the ENIB internal pack used in our course (SDK pack), enabling efficient development and debugging of firmware for the embedded system.","title":"Microcontroller Development Kit"},{"location":"SHT40_SENSOR/#software-implementation","text":"Before we can utilize the SHT40 sensor, it is crucial to establish communication with it using the I2C protocol and configure it with the appropriate settings. To achieve this, we need to implement basic functions that facilitate communication with the sensor. These functions serve as the foundation for all subsequent interactions with the sensor.","title":"Software Implementation"},{"location":"SHT40_SENSOR/#project-structure","text":"To integrate the SHT40 sensor into our project, you'll need to follow these steps: Create the necessary files: sht40.h : Header file for SHT40 sensor interface. sht40.c : Source file for SHT40 sensor implementation.","title":"Project Structure"},{"location":"SHT40_SENSOR/#essential-functions-for-sensor-communication","text":"To interact with the SHT40 sensor, we implement the following fundamental functions: sht4x_write(uint8_t reg, uint8_t value) : This function writes a single byte of data to a specified register of the sensor.. static int16_t sht4x_write(uint8_t reg, uint8_t value) { uint8_t data[2]; data[0] = reg; data[1] = value & 0xFF; return i2c_write(I2C1, SHT4X_ADDRESS, data, sizeof(data)); } read(uint8_t reg , int delay) : This function reads a single byte of data from a specified register of the sensor. static uint8_t sht4x_read(uint8_t reg, int delay) { uint8_t value; uint8_t reg_data[1] = {reg}; if (i2c_write(I2C1, SHT4X_ADDRESS, reg_data, 1) != I2C_OK) { uart_puts(_USART2, \"\\n\\rErreur lors de l'\u00e9criture dans le registre\\n\"); return 0; } delay_us(delay); if (i2c_read(I2C1, SHT4X_ADDRESS, &value, 1) != I2C_OK) { uart_puts(_USART2, \"\\n\\rErreur lors de la lecture d'octets\\n\"); return 0; } return value; } write_n(uint8_t reg, uint8_t* values, uint8_t length) : This function writes multiple bytes of data to consecutive registers of the sensor. static int16_t sht4x_write_n(uint8_t reg, uint8_t* values, uint8_t length) { uint8_t data[length + 1]; data[0] = reg; for (size_t i = 0; i < length; i++) { data[i + 1] = values[i]; } return i2c_write(I2C1, SHT4X_ADDRESS, data, sizeof(data)); } read_n(uint8_t reg, uint8_t* values, uint8_t length, int delay) : This function reads multiple bytes of data from consecutive registers of the sensor. void read_n(uint8_t reg, uint8_t* values, uint8_t length, int delay) { uint8_t reg_data[1] = {reg}; if (i2c_write(I2C1, SHT4X_ADDRESS, reg_data, 1) != I2C_OK) { uart_puts(_USART2,\"\\n\\rErreur lors de l'\u00e9criture dans le registre\\n\"); return I2C_ERROR; } delay_us(delay); if (i2c_read(I2C1, SHT4X_ADDRESS, values, length) != I2C_OK) { uart_puts(_USART2,\"\\n\\rErreur lors de la lecture d'octets\\n\"); return; } } sht4x_write_cmd(const uint8_t* cmd) : This function writes a command to the sensor. static int16_t sht4x_write_cmd(const uint8_t* cmd) { return i2c_write(I2C1, SHT4X_ADDRESS, cmd, 1); } sht4x_write_cmd(const uint8_t* cmd) : This function writes a command to the sensor. static int16_t sht4x_write_cmd(const uint8_t* cmd) { return i2c_write(I2C1, SHT4X_ADDRESS, cmd, 1); } These functions provide the necessary groundwork for interacting with the SHT40 sensor via the I2C protocol. Once implemented, we can proceed with initializing the sensor and configuring it according to our project requirements.","title":"Essential Functions for Sensor Communication"},{"location":"SHT40_SENSOR/#key-details-about-the-sht40-sensor","text":"","title":"Key Details about the SHT40 Sensor"},{"location":"SHT40_SENSOR/#i2c-communication","text":"Specification: Based on NXP\u2019s I2C-bus specification. Supported Modes: Standard, fast mode, and fast mode plus. Data Transfer: Transferred in multiples of 16-bit words with an 8-bit checksum (CRC). Addressing: 7-bit I2C address followed by an eighth bit, denoting communication direction. Documentation: SHT40 Documentation","title":"I2C Communication:"},{"location":"SHT40_SENSOR/#data-type-length","text":"Operates with: 8-bit data packages. Checksum: Included after every second 8-bit data package. Transmission: Humidity and temperature data transmitted in a specific format.","title":"Data Type &amp; Length:"},{"location":"SHT40_SENSOR/#checksum-calculation","text":"For Read Transfers: Each 16-bit data is followed by a checksum using CRC-8 algorithm.","title":"Checksum Calculation:"},{"location":"SHT40_SENSOR/#command-overview","text":"Various Commands: Available for different operations like measuring temperature and humidity, reading serial number, etc. Refer to the documentation for detailed specifications and usage instructions.","title":"Command Overview:"},{"location":"SHT40_SENSOR/#sensor-initialization","text":"To use the SHT40 sensor, we need to initialize the I2C communication and configure the sensor. For initialization, we first read the serial number to ensure that the sensor is connected and functioning properly. The process involves detecting if a sensor is connected by reading the ID register. If the sensor does not respond or if the response is not the expected value, the test fails. /** * Detects if a sensor is connected by reading out the ID register. If the sensor does not answer * or if the answer is not the expected value, the test fails. * * @return 0 if a sensor was detected */ int16_t sht4x_probe(void); int16_t sht4x_probe(void) { uint32_t serial; return sht4x_read_serial(&serial); } // Internal function to retrieve the number of words divided by the word size (2 bytes) #define SENSIRION_WORD_SIZE 2 #define SENSIRION_NUM_WORDS(x) (sizeof(x) / SENSIRION_WORD_SIZE) // Duration necessary to write command #define SHT4X_CMD_DURATION_USEC int16_t sht4x_read_serial(uint32_t* serial) { const uint8_t cmd = SHT4X_CMD_READ_SERIAL; int16_t ret; uint16_t serial_words[SENSIRION_NUM_WORDS(*serial)]; ret = write_cmd(&sht4x_cmd_measure); if (ret) return ret; read_n((uint8_t*)serial_words,sizeof(serial_words)); *serial = ((uint32_t)serial_words[0] << 16) | serial_words[1]; return I2C_OK; }","title":"Sensor Initialization"},{"location":"SHT40_SENSOR/#task-one","text":"After initialization, we can now retrieve the temperature and humidity data. To do this, we need to create a function that allows us to read the temperature and humidity. Below is the function we developed: int16_t sht4x_measure_blocking_read(float* temperature, float* humidity) { int16_t ret; ret = write_cmd(&sht4x_cmd_measure); if (ret) return ret; delay_us(sht4x_cmd_measure_delay_us); return sht4x_read_measurement(temperature, humidity); }","title":"Task One"},{"location":"SHT40_SENSOR/#function-explanation","text":"To read the temperature, we start by writing a command. After this, we can read the data. Similar to other sensors where a register pointer is used, we first send a write header to the I2C slave followed by a command. For example, \"measure RH&T with highest precision.\" After the measurement is finished, the read request directed to the I2C slave will be acknowledged, and the transmission of data will be started by the slave.","title":"Function Explanation"},{"location":"SHT40_SENSOR/#here-is-an-image-explaining-the-process","text":"After sending the command, we can read the temperature and humidity. We need to use a formula to convert each value correctly. Refer to the documentation SHT40 Documentation for more details. int16_t sht4x_read_measurement(float* temperature, float* humidity) { uint16_t rawTemp, rawHumd; uint16_t words[2]; int16_t ret = read_n(words,SENSIRION_NUM_WORDS(words)); if (ret) return ret; /** * formulas for conversion of the sensor signals, optimized for fixed point * algebra: * Temperature = 175 * S_T / 65535 - 45 * Relative Humidity = 125 * (S_RH / 65535) - 6 */ rawTemp = ((uint16_t) words[0] << 8) | words[1]; rawHumd = ((uint16_t) words[2] << 8) | words[3]; *temperature = (-45.0f + 175.0f * (rawTemp / 65535.0f)); *humidity = (-6.0f + 125.0f * (rawHumd / 65535.0f)); return ret; }","title":"Here is an image explaining the process:"},{"location":"SHT40_SENSOR/#task-two","text":"Great, now we can test if this works well. We need to use serial UART ST-LINK to display the current temperature and humidity in the terminal. Here is a test where we define main.c. We will do the first test by adding some code to transform a float into two parts: the integer part and the decimal part. #include \"libshield/sht4x.h\" #define delay_us(us) timer_wait_us(_TIM3, us) static void on_command_received(char c) { command = c; } int main(void) { uart_init(_USART2, 115200, UART_8N1, on_command_received); i2c_master_init(_I2C1); while (sht4x_probe() != 0) { uart_printf(UART_TO_USE, \"SHT sensor probing failed\\n\"); delay_us(1000); // Sleep 1s } while (1) { float temperature, humidity; int8_t ret = sht4x_measure_blocking_read(&temperature, &humidity); if (ret == 0) { int temp_int = (int) temperature; float temp_frac = temperature - temp_int; int hum_int = (int) humidity; float hum_frac = humidity - hum_int; int temp_int_frac = (int)(temp_frac * 1000); int hum_int_frac = (int)(hum_frac * 1000); uart_printf(UART_TO_USE, \"\\r\\ntemperature: %d.%d C\", temp_int, temp_int_frac); uart_printf(UART_TO_USE, \"\\r\\nhumidity: %d.%d\", hum_int, hum_int_frac); delay_us(1000); // Sleep 1s } else { uart_printf(UART_TO_USE, \"\\r\\nError reading measurement\"); } break; } return 0; }","title":"Task Two"},{"location":"SHT40_SENSOR/#summary","text":"In this section, we include the essential details about the SHT40 sensor, its basic functionalities, and how to interface it with a microcontroller to read and display temperature and humidity values using UART. We also provide a sample code implementation for initializing the sensor, reading data, and handling errors. After this, we will add more extra features and improvements to enhance the functionality and reliability of the system.","title":"Summary"},{"location":"TCS3414CS_SENSOR/","text":"TCS34725CS SENSOR This section provides a detailed explanation of the embedded system aspect of our project, focusing specifically on the Grove The TCS34725CS color sensor. Hardware Components Microcontroller Development Kit We utilize an STM32 microcontroller development kit to build and debug code for the card. This development kit, provided by the ENIB internal pack we use in our course ( SDK pack ), allows us to efficiently develop and debug firmware for the embedded system. Software Implementation Before we can utilize the TCS34725CS sensor, it's crucial to establish communication with it using the I2C protocol and configure it with the appropriate settings. To achieve this, we need to implement basic functions that facilitate communication with the sensor. These functions serve as the foundation for all subsequent interactions with the sensor. Project Structure To integrate the TCS34725CS sensor into our project, follow these steps: Create the necessary files: TCS34725CS.h : Header file for the TCS34725CS sensor interface. TCS34725CS.c : Source file for the TCS34725CS sensor implementation. Essential Functions for Sensor Communication To interact with the TCS34725CS sensor, we implement the following fundamental functions in addition to the basic functions previously discussed for the SHT40 sensor. One of these functions allows us to get a 16-bit value from the sensor: uint16_t read16(uint8_t reg) { uint16_t x; uint8_t reg_data[1] = { TCS34725_COMMAND_BIT | reg }; if (i2c_write(I2C1, TCS34725_ADDRESS, reg_data, 1) != I2C_OK) { uart_puts(_USART2, \"\\n\\rErreur lors de l'\u00e9criture dans le registre\\n\"); return 0; } uint8_t data[2]; if (i2c_read(I2C1, TCS34725_ADDRESS, data, 2) != I2C_OK) { uart_puts(_USART2, \"\\n\\rErreur lors de la lecture d'octets\\n\"); return 0; } x = data[1]; x <<= 8; x |= data[0]; return x; } Command Bit The TCS34725_COMMAND_BIT is defined as 0x80. This bit is used to indicate that the following byte is a command for the TCS34725CS sensor. When interacting with the sensor, this bit is OR-ed with the register address to form the command byte. Sensor Initialization To use the TCS34725CS sensor, we need to initialize the I2C communication and configure the sensor. For initialization, we first read the serial number to ensure that the sensor is connected and functioning properly. The process involves detecting if a sensor is connected by reading out the ID register. If the sensor does not answer or if the answer is not the expected value, the test fails. void tcs34725_init(void) { // Initialize I2C communication on I2C1 // Check if the initialization was successful if (i2c_master_init(I2C1) != I2C_OK) { // If I2C initialization fails, print an error message to the UART uart_puts(_USART2, \"\\n\\rErreur: Communication I2C non initialis\u00e9e\\n\"); return; } // Read the ID register of the TCS34725 sensor uint8_t id = read8(TCS34725_ID); // Check if the ID matches the expected values (0x44 or 0x10) if ((id != 0x44) && (id != 0x10)) { // If the ID does not match, print an error message to the UART uart_puts(_USART2, \"\\n\\rErreur: ID Incorrect\\n\"); return; } // Define the configuration for the TCS34725 sensor tcs34725_config_t config = { .enable = TCS34725_ENABLE_PON | TCS34725_ENABLE_AEN, // Enable the power-on and ADC .integration_time = TCS34725_INTEGRATIONTIME_700MS, // Set the integration time to 700ms .gain = TCS34725_GAIN_1X // Set the gain to 1x }; // Write the configuration settings to the sensor write8(TCS34725_ENABLE, config.enable); // Enable the sensor write8(TCS34725_ATIME, config.integration_time); // Set the integration time write8(TCS34725_CONTROL, config.gain); // Set the gain return; } Task One Reading RGB and Clear Values After the initialization is complete, we need to develop a function to retrieve the RGB and clear values from the sensor. Here is the function to do this: /** * @brief Reads the RGB and clear values from the TCS34725 sensor. * * This function reads the clear, red, green, and blue data from their respective * data registers. It also waits for the appropriate integration time to ensure * the data is ready before reading. * * @param red Pointer to store the red value. * @param green Pointer to store the green value. * @param blue Pointer to store the blue value. * @param clear Pointer to store the clear value. */ void tcs34725_read_color(uint16_t *red, uint16_t *green, uint16_t *blue, uint16_t *clear) { // Read the clear, red, green, and blue data from their respective data registers *clear = read16(TCS34725_CDATAL); *red = read16(TCS34725_RDATAL); *green = read16(TCS34725_GDATAL); *blue = read16(TCS34725_BDATAL); // Read the integration time register uint8_t atime_reg = read8(TCS34725_ATIME); // Calculate the integration time in milliseconds uint16_t integration_time = (256 - atime_reg) * 2.4; // Wait for the integration time to ensure data is ready // Note: The delay_us function is assumed to be available for microsecond delays switch (integration_time) { case 2: // 2.4 ms delay_us(3000); // Delay for 3 ms to ensure data is ready break; case 24: // 24 ms delay_us(24000); // Delay for 24 ms to ensure data is ready break; case 50: // 50 ms delay_us(50000); // Delay for 50 ms to ensure data is ready break; case 101: // 101 ms delay_us(101000); // Delay for 101 ms to ensure data is ready break; case 154: // 154 ms delay_us(154000); // Delay for 154 ms to ensure data is ready break; case 700: // 700 ms delay_us(700000); // Delay for 700 ms to ensure data is ready break; default: // If the integration time does not match any of the cases, no delay is needed break; } } The switch-case statement uses the calculated integration time to delay the appropriate amount of time to ensure the data is ready. The delay_us function is assumed to be available to create delays in microseconds. The delay times are adjusted slightly to ensure proper timing. Calculating Color Temperature After obtaining the RGB values, we can calculate the color temperature using the following function This function uses the RGB values to calculate the CIE 1931 XYZ color space values,and then computes the correlated color temperature (CCT) using the CIE 1931 xy chromaticity coordinates. /** * @brief Calculates the color temperature from the RGB values. * @param r Red value. * @param g Green value. * @param b Blue value. * @param x Pointer to store the x chromaticity coordinate. * @param y Pointer to store the y chromaticity coordinate. * @return The calculated color temperature in Kelvin. */ float calculateColorTemperature(uint16_t r, uint16_t g, uint16_t b, float *x, float *y) { float X, Y, Z; float XYZ_sum; // Convert RGB values to CIE 1931 XYZ color space(The RGB values are converted to the CIE 1931 XYZ color space using the following equations) X = (-0.14282f * r + 1.54924f * g - 0.95641f * b); Y = (-0.32466f * r + 1.57837f * g - 0.73191f * b); Z = (-0.68202f * r + 0.77073f * g + 0.56332f * b); // Sum of XYZ components XYZ_sum = X + Y + Z; if (XYZ_sum != 0) { // Calculate the x and y chromaticity coordinates *x = X / XYZ_sum; *y = Y / XYZ_sum; } else { // Default values if XYZ_sum is zero *x = 0.3320f; *y = 0.1858f; } // Calculate n value used in the CCT formula float n = (*x - 0.3320f) / (0.1858f - *y); // Calculate the correlated color temperature (CCT) using the CIE 1931 xy to CCT formula // CCT = 437*n^3 + 3601*n^2 + 6861*n + 5517 float cct = ((437 * n * n * n) + (3601 * n * n) + (6861 * n) + 5517); return cct; } For more information on the CIE 1931 xy to CCT formula, you can refer to this ( link ) Calculating Illuminance (Lux) After obtaining the RGB values, we can calculate the illuminance (lux) using the following function: /** * @brief Calculates the illuminance (lux) from the RGB values. * * This function uses the RGB values to calculate the illuminance in lux based on * a weighted sum of the red, green, and blue components. * * @param r Red value. * @param g Green value. * @param b Blue value. * @return The calculated illuminance in lux. */ float calculateLux(uint16_t r, uint16_t g, uint16_t b) { float illuminance; // Calculate illuminance using a weighted sum of the RGB values // The weights are derived from the spectral sensitivity of the sensor illuminance = (-0.32466f * r) + (1.57837f * g) + (-0.73191f * b); // Return the calculated illuminance return (uint16_t)illuminance; } By using this function, you can convert the RGB values obtained from the TCS34725 sensor into an illuminance value in lux, providing a measure of the light intensity. For more detailed information on how illuminance is calculated from RGB values and the spectral sensitivity of the sensor, you can refer to relevant technical documentation and research papers on color sensing and photometry. Task Two Testing Color and Illuminance Calculation Great, now we can test if this works well. We need to use serial UART ST-LINK to display x, y, lux, and color temperature in Kelvin in the terminal. Here is a test where we define main.c . case 'c': {// Get current color uint16_t red, green, blue, clear, color_temp, lux; float x, y; tcs34725_read_color(&red, &green, &blue, &clear); color_temp = calculateColorTemperature(red, green, blue, &x, &y); lux = calculateLux(red, green, blue); // Convertir les coordonn\u00e9es chromatiques en parties enti\u00e8res et d\u00e9cimales int x_int =(int)x; float x_frac = x-x_int; int x_frac_int = (int)(x_frac * 1000); int y_int = (int)y; float y_frac = y-y_int; int y_frac_int= (int)(y_frac*1000); // Afficher (x,y) avec illuminance (color + brightness ) uart_printf(UART_TO_USE, \"\\r\\nx = %d.%d , y=%d.%d, illuminance=%d\\r\\n\", x_int, x_frac_int, y_int, y_frac_int,lux); uart_printf(UART_TO_USE, \"\\r\\nTemperature en Kelvin: %d\\n\", color_temp); timer_start(_TIM2); // Sleep 1s #endif break; } Example Output When the sensor detects color and calculates the values, the output in the terminal might look like this: x = 0.332, y = 0.185, illuminance = 123 Temperature in Kelvin: 5500 Verification We can verify if the x, y coordinates and the lux values are correct by using a CIE 1931 xy to CCT calculator. Here is an example showing the process: For more information on the CIE 1931 xy to CCT formula and how to use it, you can refer to this ( link ) Summary In this section, we include the essential details about the TCS34725CS sensor, its basic functionalities, and how to interface it with a microcontroller to read and display color temperature, chromaticity coordinates, and illuminance values using UART. We also provide a sample code implementation for initializing the sensor, reading data, and handling errors.","title":"TCS34725CS SENSOR"},{"location":"TCS3414CS_SENSOR/#tcs34725cs-sensor","text":"This section provides a detailed explanation of the embedded system aspect of our project, focusing specifically on the Grove The TCS34725CS color sensor.","title":"TCS34725CS SENSOR"},{"location":"TCS3414CS_SENSOR/#hardware-components","text":"","title":"Hardware Components"},{"location":"TCS3414CS_SENSOR/#microcontroller-development-kit","text":"We utilize an STM32 microcontroller development kit to build and debug code for the card. This development kit, provided by the ENIB internal pack we use in our course ( SDK pack ), allows us to efficiently develop and debug firmware for the embedded system.","title":"Microcontroller Development Kit"},{"location":"TCS3414CS_SENSOR/#software-implementation","text":"Before we can utilize the TCS34725CS sensor, it's crucial to establish communication with it using the I2C protocol and configure it with the appropriate settings. To achieve this, we need to implement basic functions that facilitate communication with the sensor. These functions serve as the foundation for all subsequent interactions with the sensor.","title":"Software Implementation"},{"location":"TCS3414CS_SENSOR/#project-structure","text":"To integrate the TCS34725CS sensor into our project, follow these steps: Create the necessary files: TCS34725CS.h : Header file for the TCS34725CS sensor interface. TCS34725CS.c : Source file for the TCS34725CS sensor implementation.","title":"Project Structure"},{"location":"TCS3414CS_SENSOR/#essential-functions-for-sensor-communication","text":"To interact with the TCS34725CS sensor, we implement the following fundamental functions in addition to the basic functions previously discussed for the SHT40 sensor. One of these functions allows us to get a 16-bit value from the sensor: uint16_t read16(uint8_t reg) { uint16_t x; uint8_t reg_data[1] = { TCS34725_COMMAND_BIT | reg }; if (i2c_write(I2C1, TCS34725_ADDRESS, reg_data, 1) != I2C_OK) { uart_puts(_USART2, \"\\n\\rErreur lors de l'\u00e9criture dans le registre\\n\"); return 0; } uint8_t data[2]; if (i2c_read(I2C1, TCS34725_ADDRESS, data, 2) != I2C_OK) { uart_puts(_USART2, \"\\n\\rErreur lors de la lecture d'octets\\n\"); return 0; } x = data[1]; x <<= 8; x |= data[0]; return x; }","title":"Essential Functions for Sensor Communication"},{"location":"TCS3414CS_SENSOR/#command-bit","text":"The TCS34725_COMMAND_BIT is defined as 0x80. This bit is used to indicate that the following byte is a command for the TCS34725CS sensor. When interacting with the sensor, this bit is OR-ed with the register address to form the command byte.","title":"Command Bit"},{"location":"TCS3414CS_SENSOR/#sensor-initialization","text":"To use the TCS34725CS sensor, we need to initialize the I2C communication and configure the sensor. For initialization, we first read the serial number to ensure that the sensor is connected and functioning properly. The process involves detecting if a sensor is connected by reading out the ID register. If the sensor does not answer or if the answer is not the expected value, the test fails. void tcs34725_init(void) { // Initialize I2C communication on I2C1 // Check if the initialization was successful if (i2c_master_init(I2C1) != I2C_OK) { // If I2C initialization fails, print an error message to the UART uart_puts(_USART2, \"\\n\\rErreur: Communication I2C non initialis\u00e9e\\n\"); return; } // Read the ID register of the TCS34725 sensor uint8_t id = read8(TCS34725_ID); // Check if the ID matches the expected values (0x44 or 0x10) if ((id != 0x44) && (id != 0x10)) { // If the ID does not match, print an error message to the UART uart_puts(_USART2, \"\\n\\rErreur: ID Incorrect\\n\"); return; } // Define the configuration for the TCS34725 sensor tcs34725_config_t config = { .enable = TCS34725_ENABLE_PON | TCS34725_ENABLE_AEN, // Enable the power-on and ADC .integration_time = TCS34725_INTEGRATIONTIME_700MS, // Set the integration time to 700ms .gain = TCS34725_GAIN_1X // Set the gain to 1x }; // Write the configuration settings to the sensor write8(TCS34725_ENABLE, config.enable); // Enable the sensor write8(TCS34725_ATIME, config.integration_time); // Set the integration time write8(TCS34725_CONTROL, config.gain); // Set the gain return; }","title":"Sensor Initialization"},{"location":"TCS3414CS_SENSOR/#task-one","text":"","title":"Task One"},{"location":"TCS3414CS_SENSOR/#reading-rgb-and-clear-values","text":"After the initialization is complete, we need to develop a function to retrieve the RGB and clear values from the sensor. Here is the function to do this: /** * @brief Reads the RGB and clear values from the TCS34725 sensor. * * This function reads the clear, red, green, and blue data from their respective * data registers. It also waits for the appropriate integration time to ensure * the data is ready before reading. * * @param red Pointer to store the red value. * @param green Pointer to store the green value. * @param blue Pointer to store the blue value. * @param clear Pointer to store the clear value. */ void tcs34725_read_color(uint16_t *red, uint16_t *green, uint16_t *blue, uint16_t *clear) { // Read the clear, red, green, and blue data from their respective data registers *clear = read16(TCS34725_CDATAL); *red = read16(TCS34725_RDATAL); *green = read16(TCS34725_GDATAL); *blue = read16(TCS34725_BDATAL); // Read the integration time register uint8_t atime_reg = read8(TCS34725_ATIME); // Calculate the integration time in milliseconds uint16_t integration_time = (256 - atime_reg) * 2.4; // Wait for the integration time to ensure data is ready // Note: The delay_us function is assumed to be available for microsecond delays switch (integration_time) { case 2: // 2.4 ms delay_us(3000); // Delay for 3 ms to ensure data is ready break; case 24: // 24 ms delay_us(24000); // Delay for 24 ms to ensure data is ready break; case 50: // 50 ms delay_us(50000); // Delay for 50 ms to ensure data is ready break; case 101: // 101 ms delay_us(101000); // Delay for 101 ms to ensure data is ready break; case 154: // 154 ms delay_us(154000); // Delay for 154 ms to ensure data is ready break; case 700: // 700 ms delay_us(700000); // Delay for 700 ms to ensure data is ready break; default: // If the integration time does not match any of the cases, no delay is needed break; } } The switch-case statement uses the calculated integration time to delay the appropriate amount of time to ensure the data is ready. The delay_us function is assumed to be available to create delays in microseconds. The delay times are adjusted slightly to ensure proper timing.","title":"Reading RGB and Clear Values"},{"location":"TCS3414CS_SENSOR/#calculating-color-temperature","text":"After obtaining the RGB values, we can calculate the color temperature using the following function This function uses the RGB values to calculate the CIE 1931 XYZ color space values,and then computes the correlated color temperature (CCT) using the CIE 1931 xy chromaticity coordinates. /** * @brief Calculates the color temperature from the RGB values. * @param r Red value. * @param g Green value. * @param b Blue value. * @param x Pointer to store the x chromaticity coordinate. * @param y Pointer to store the y chromaticity coordinate. * @return The calculated color temperature in Kelvin. */ float calculateColorTemperature(uint16_t r, uint16_t g, uint16_t b, float *x, float *y) { float X, Y, Z; float XYZ_sum; // Convert RGB values to CIE 1931 XYZ color space(The RGB values are converted to the CIE 1931 XYZ color space using the following equations) X = (-0.14282f * r + 1.54924f * g - 0.95641f * b); Y = (-0.32466f * r + 1.57837f * g - 0.73191f * b); Z = (-0.68202f * r + 0.77073f * g + 0.56332f * b); // Sum of XYZ components XYZ_sum = X + Y + Z; if (XYZ_sum != 0) { // Calculate the x and y chromaticity coordinates *x = X / XYZ_sum; *y = Y / XYZ_sum; } else { // Default values if XYZ_sum is zero *x = 0.3320f; *y = 0.1858f; } // Calculate n value used in the CCT formula float n = (*x - 0.3320f) / (0.1858f - *y); // Calculate the correlated color temperature (CCT) using the CIE 1931 xy to CCT formula // CCT = 437*n^3 + 3601*n^2 + 6861*n + 5517 float cct = ((437 * n * n * n) + (3601 * n * n) + (6861 * n) + 5517); return cct; } For more information on the CIE 1931 xy to CCT formula, you can refer to this ( link )","title":"Calculating Color Temperature"},{"location":"TCS3414CS_SENSOR/#calculating-illuminance-lux","text":"After obtaining the RGB values, we can calculate the illuminance (lux) using the following function: /** * @brief Calculates the illuminance (lux) from the RGB values. * * This function uses the RGB values to calculate the illuminance in lux based on * a weighted sum of the red, green, and blue components. * * @param r Red value. * @param g Green value. * @param b Blue value. * @return The calculated illuminance in lux. */ float calculateLux(uint16_t r, uint16_t g, uint16_t b) { float illuminance; // Calculate illuminance using a weighted sum of the RGB values // The weights are derived from the spectral sensitivity of the sensor illuminance = (-0.32466f * r) + (1.57837f * g) + (-0.73191f * b); // Return the calculated illuminance return (uint16_t)illuminance; } By using this function, you can convert the RGB values obtained from the TCS34725 sensor into an illuminance value in lux, providing a measure of the light intensity. For more detailed information on how illuminance is calculated from RGB values and the spectral sensitivity of the sensor, you can refer to relevant technical documentation and research papers on color sensing and photometry.","title":"Calculating Illuminance (Lux)"},{"location":"TCS3414CS_SENSOR/#task-two","text":"","title":"Task Two"},{"location":"TCS3414CS_SENSOR/#testing-color-and-illuminance-calculation","text":"Great, now we can test if this works well. We need to use serial UART ST-LINK to display x, y, lux, and color temperature in Kelvin in the terminal. Here is a test where we define main.c . case 'c': {// Get current color uint16_t red, green, blue, clear, color_temp, lux; float x, y; tcs34725_read_color(&red, &green, &blue, &clear); color_temp = calculateColorTemperature(red, green, blue, &x, &y); lux = calculateLux(red, green, blue); // Convertir les coordonn\u00e9es chromatiques en parties enti\u00e8res et d\u00e9cimales int x_int =(int)x; float x_frac = x-x_int; int x_frac_int = (int)(x_frac * 1000); int y_int = (int)y; float y_frac = y-y_int; int y_frac_int= (int)(y_frac*1000); // Afficher (x,y) avec illuminance (color + brightness ) uart_printf(UART_TO_USE, \"\\r\\nx = %d.%d , y=%d.%d, illuminance=%d\\r\\n\", x_int, x_frac_int, y_int, y_frac_int,lux); uart_printf(UART_TO_USE, \"\\r\\nTemperature en Kelvin: %d\\n\", color_temp); timer_start(_TIM2); // Sleep 1s #endif break; }","title":"Testing Color and Illuminance Calculation"},{"location":"TCS3414CS_SENSOR/#example-output","text":"When the sensor detects color and calculates the values, the output in the terminal might look like this: x = 0.332, y = 0.185, illuminance = 123 Temperature in Kelvin: 5500","title":"Example Output"},{"location":"TCS3414CS_SENSOR/#verification","text":"We can verify if the x, y coordinates and the lux values are correct by using a CIE 1931 xy to CCT calculator. Here is an example showing the process: For more information on the CIE 1931 xy to CCT formula and how to use it, you can refer to this ( link )","title":"Verification"},{"location":"TCS3414CS_SENSOR/#summary","text":"In this section, we include the essential details about the TCS34725CS sensor, its basic functionalities, and how to interface it with a microcontroller to read and display color temperature, chromaticity coordinates, and illuminance values using UART. We also provide a sample code implementation for initializing the sensor, reading data, and handling errors.","title":"Summary"},{"location":"Test/","text":"Test Microcontroleur Prerequisites Before cloning and testing the project, ensure that you have the following prerequisites installed: ENIB Kit : You need to install the ENIB kit from here to use certain features of the project. Cloning and Testing Our Project To clone and test our project, follow these steps: 1- Clone the Repository : Open your terminal or command prompt and run the following command to clone the repository to your local machine: git clone https://github.com/Eljily-Mohamed/Projet-Emb.git 2- Navigate to Project Directory : Change your current directory to the project directory by running: cd Projet-Emb 3- Make the Project :you can use the make command to build the project. Run: make 4- Launch the Debug File : You need to launch the debug file. Use the following command to debug the main.elf file Run: dbg main.elf 5- Test with st-link : You can use minicom, gtkterm, or any similar terminal emulator to display the temperature and humidity. Ensure you use the port ttyACM0 and set the baud rate to 115200. You can start minicom with the following command. Run: minicom -D /dev/ttyACM0 -b 115200 6- Get Temperature and Humidity : After starting minicom, to get the temperature and humidity, type the command: commande = t 7- Get color Infos : After starting minicom, to get the color information such as(temperature (Kelvin) , lux, ..), type the command: commande = c Following this guide, you should be able to successfully clone, build, and test our microcontroller project IHM \ud83d\ude80 Getting Started Ces instructions vous permettront d'obtenir une copie du projet en cours d'ex\u00e9cution sur votre machine locale \u00e0 des fins de d\u00e9veloppement et de test. Pr\u00e9requis Avant de commencer, assurez-vous d'avoir Node.js et npm install\u00e9s sur votre machine. Installation Clonez ce d\u00e9p\u00f4t GitHub sur votre machine locale en utilisant la commande suivante : git clone https://github.com/Eljily-Mohamed/emb-projet-ihm.git Acc\u00e9dez au r\u00e9pertoire nouvellement cr\u00e9\u00e9 : cd emb-projet-ihm Installez les d\u00e9pendances en ex\u00e9cutant la commande suivante : npm install \ud83d\udd27 Utilisation Pour lancer l'application, ex\u00e9cutez la commande suivante : npm run electron-dev","title":"Test"},{"location":"Test/#test","text":"","title":"Test"},{"location":"Test/#microcontroleur","text":"","title":"Microcontroleur"},{"location":"Test/#prerequisites","text":"Before cloning and testing the project, ensure that you have the following prerequisites installed: ENIB Kit : You need to install the ENIB kit from here to use certain features of the project.","title":"Prerequisites"},{"location":"Test/#cloning-and-testing-our-project","text":"To clone and test our project, follow these steps: 1- Clone the Repository : Open your terminal or command prompt and run the following command to clone the repository to your local machine: git clone https://github.com/Eljily-Mohamed/Projet-Emb.git 2- Navigate to Project Directory : Change your current directory to the project directory by running: cd Projet-Emb 3- Make the Project :you can use the make command to build the project. Run: make 4- Launch the Debug File : You need to launch the debug file. Use the following command to debug the main.elf file Run: dbg main.elf 5- Test with st-link : You can use minicom, gtkterm, or any similar terminal emulator to display the temperature and humidity. Ensure you use the port ttyACM0 and set the baud rate to 115200. You can start minicom with the following command. Run: minicom -D /dev/ttyACM0 -b 115200 6- Get Temperature and Humidity : After starting minicom, to get the temperature and humidity, type the command: commande = t 7- Get color Infos : After starting minicom, to get the color information such as(temperature (Kelvin) , lux, ..), type the command: commande = c Following this guide, you should be able to successfully clone, build, and test our microcontroller project","title":"Cloning and Testing Our Project"},{"location":"Test/#ihm","text":"","title":"IHM"},{"location":"Test/#getting-started","text":"Ces instructions vous permettront d'obtenir une copie du projet en cours d'ex\u00e9cution sur votre machine locale \u00e0 des fins de d\u00e9veloppement et de test.","title":"\ud83d\ude80 Getting Started"},{"location":"Test/#prerequis","text":"Avant de commencer, assurez-vous d'avoir Node.js et npm install\u00e9s sur votre machine.","title":"Pr\u00e9requis"},{"location":"Test/#installation","text":"Clonez ce d\u00e9p\u00f4t GitHub sur votre machine locale en utilisant la commande suivante : git clone https://github.com/Eljily-Mohamed/emb-projet-ihm.git Acc\u00e9dez au r\u00e9pertoire nouvellement cr\u00e9\u00e9 : cd emb-projet-ihm Installez les d\u00e9pendances en ex\u00e9cutant la commande suivante : npm install","title":"Installation"},{"location":"Test/#utilisation","text":"Pour lancer l'application, ex\u00e9cutez la commande suivante : npm run electron-dev","title":"\ud83d\udd27 Utilisation"},{"location":"Wireless/","text":"Wireless Connection Zigbee Zigbee is a wireless communication protocol designed for low-power, low-data-rate applications. It operates on the IEEE 802.15.4 standard and is commonly used in home automation, industrial control, and sensor networks. Zigbee networks can support hundreds of devices, making it suitable for applications requiring long battery life and reliable communication over short to medium distances. UART1 Configuration Steps To configure UART1 in the .config file and define different pins and GPIO configurations: // USART1 #define USE_USART1 #define USART1_GPIO_PORT _GPIOB #define USART1_GPIO_PINS PIN_3 #define USART1_GPIO_CFG PIN_MODE_ALTFUNC | PIN_OPT_AF7 // USART2 #define USE_USART2 #define USART2_GPIO_PORT _GPIOA #define USART2_GPIO_PINS PIN_2 | PIN_3 | PIN_9 #define USART2_GPIO_CFG PIN_MODE_ALTFUNC | PIN_OPT_AF7 For more details, check the documentation, and you need to be familiar with using the ENIB Kit for Embedded Systems UART1 Initialization and Callback int uart_init(USART_t *u, uint32_t baud, uint32_t mode, OnUartRx cb) { IRQn_t irq_number; uint32_t irq_priority; if (u == _USART1) { #ifdef USE_USART1 // Enable USART clocking _RCC->APB2ENR |= (1 << 4); // Configure Tx/Rx pins io_configure(USART1_GPIO_PORT, USART1_GPIO_PINS, USART1_GPIO_CFG, NULL); usart1_cb = cb; irq_number = USART1_IRQn; irq_priority = USART1_IRQ_PRIORITY; // Configure USART speed u->BRR = sysclks.apb2_freq / baud; #else return -1; // USART1 not enabled #endif } /*Reset usart conf */ u->CR1&=~(1<<12); //nb de bit par data raz u->CR1&=~(7<<8); //parit\u00e9 raz u->CR2&=~(3<<12); //bit stop u->GTPR = 0; u->CR3 = 0; /*conf \u00e0 partir mode */ /* mode = b10-b9-b8-x-x-b5-b4-x-x-x-b0 b0 = 8/9 bits dans CR1 b12 b5/b4 = nb bit stop dans CR2 b13/b12 b10/b9/b8 = parit\u00e9 , 10 controle parit\u00e9 (1 activ\u00e9/0 d\u00e9sactiv\u00e9), 9 type parit\u00e9 (Odd/Even) , 8 PEIE parity Error interrupt enable */ u->CR1 |=((mode & 0x1)<<12) | (mode & 0x700) | (3<<2) | (1<<13); //conf + tx/rx activ\u00e9 + usart enable u->CR2 |=((mode & 0x30)<<8); //bit stop positionn\u00e9 en b12/b13 de CR2 // Setup NVIC if (cb) { /* A COMPLETER */ NVIC_SetPriority(irq_number, irq_priority); NVIC_EnableIRQ(irq_number); u->CR1 |= (1<<5);// Receiver Not Empty Interrupt Enable } } Test In the main file, we need to add a callback function to handle communication via Zigbee: static void on_zigbee_command_received(char c) { command = c; uart_printf(UART_TO_USE, \"\\r\\nZigbee command received: %c\\r\\n\", c); } // Initialization required uart_init(_USART2, 115200, UART_8N1, on_command_received); uart_init(_USART1, 115200, UART_8N1, on_zigbee_command_received); Now that we have completed these steps, we can verify if everything functions correctly by conducting the same test mentioned in the section above, but using the 'tty/USB0' port. Bluetooth Low Energy (BLE) Bluetooth Low Energy (BLE) is a wireless communication technology designed for short-range communication with minimal power consumption. It is commonly used in applications such as wearable devices, smart home products, and health monitoring systems. Hardware Requirements X-NUCLEO-IDB05A2 : This is a Bluetooth Low Energy (BLE) expansion board based on the SPBTLE-RF module. It can be used with STM32 Nucleo development boards to add BLE functionality to your projects. Configuring Our Services Temperature Service To create a BLE service for temperature data, we use the characteristic UUID 0x2A6E . // TEMPERATURE CHAR : 0x2A6E primary_short_uuid[0] = 0x6E; primary_short_uuid[1] = 0x2A; ret = aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_16, primary_short_uuid, 2, CHAR_PROP_NOTIFY | CHAR_PROP_READ, ATTR_PERMISSION_NONE, GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP, 16, 0, &TemperatureCharHandle); if (ret != BLE_STATUS_SUCCESS) { goto fail; } HAL_Delay(100); Color Temperature Service To create a BLE service for color temperature data, we use the characteristic UUID 0x2A63. // Color temp 0x2A63 primary_short_uuid[0] = 0x63; primary_short_uuid[1] = 0x2A; ret = aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_16, primary_short_uuid, 2, CHAR_PROP_NOTIFY | CHAR_PROP_READ, ATTR_PERMISSION_NONE, GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP, 16, 0, &TempColorCharHandle); if (ret != BLE_STATUS_SUCCESS) { goto fail; } HAL_Delay(100); return BLE_STATUS_SUCCESS; fail: return BLE_STATUS_ERROR; Updating Environmental Data The function Environmental_Update updates the temperature and color temperature values tBleStatus Environmental_Update(int16_t Temp, int16_t color_temp) { tBleStatus ret; uint8_t buff_Temp[2]; uint8_t buff_color_temp[2]; STORE_LE_16(buff_Temp, Temp); ret = aci_gatt_update_char_value(HWServW2STHandle, TemperatureCharHandle, 0, 2, buff_Temp); if (ret != BLE_STATUS_SUCCESS) { return BLE_STATUS_ERROR; } STORE_LE_16(buff_color_temp, color_temp); ret = aci_gatt_update_char_value(HWServW2STHandle, TempColorCharHandle, 0, 2, buff_color_temp); if (ret != BLE_STATUS_SUCCESS) { return BLE_STATUS_ERROR; } return BLE_STATUS_SUCCESS; } Sending Data After receiving a notification, you can send the updated values void SendEnvironmentalData(void) { static float temperature, humidity; uint16_t red, green, blue, clear, color_temp; float x, y; int32_t TempToSend = 0; int32_t decPart, intPart; int16_t ret; ret = sht4x_measure_blocking_read(&temperature, &humidity); tcs34725_read_color(&red, &green, &blue, &clear); color_temp = calculateColorTemperature(red, green, blue, &x, &y); MCR_BLUEMS_F2I_1D(temperature, intPart, decPart); TempToSend = intPart * 10 + decPart; printf(\"\\r\\ntemperature: %d.%d C\", intPart, decPart); printf(\"\\r\\ntemperature en kelvin: %d K\", color_temp); Environmental_Update(TempToSend, color_temp); HAL_Delay(1000); } Summary In this project, we successfully set up a Bluetooth Low Energy (BLE) communication system using the X-NUCLEO-IDB05A2 expansion board. We configured services for both temperature and color temperature data, updated these values, and sent the data using BLE notifications.","title":"Wireless Connection"},{"location":"Wireless/#wireless-connection","text":"","title":"Wireless Connection"},{"location":"Wireless/#zigbee","text":"Zigbee is a wireless communication protocol designed for low-power, low-data-rate applications. It operates on the IEEE 802.15.4 standard and is commonly used in home automation, industrial control, and sensor networks. Zigbee networks can support hundreds of devices, making it suitable for applications requiring long battery life and reliable communication over short to medium distances.","title":"Zigbee"},{"location":"Wireless/#uart1-configuration-steps","text":"To configure UART1 in the .config file and define different pins and GPIO configurations: // USART1 #define USE_USART1 #define USART1_GPIO_PORT _GPIOB #define USART1_GPIO_PINS PIN_3 #define USART1_GPIO_CFG PIN_MODE_ALTFUNC | PIN_OPT_AF7 // USART2 #define USE_USART2 #define USART2_GPIO_PORT _GPIOA #define USART2_GPIO_PINS PIN_2 | PIN_3 | PIN_9 #define USART2_GPIO_CFG PIN_MODE_ALTFUNC | PIN_OPT_AF7 For more details, check the documentation, and you need to be familiar with using the ENIB Kit for Embedded Systems","title":"UART1 Configuration Steps"},{"location":"Wireless/#uart1-initialization-and-callback","text":"int uart_init(USART_t *u, uint32_t baud, uint32_t mode, OnUartRx cb) { IRQn_t irq_number; uint32_t irq_priority; if (u == _USART1) { #ifdef USE_USART1 // Enable USART clocking _RCC->APB2ENR |= (1 << 4); // Configure Tx/Rx pins io_configure(USART1_GPIO_PORT, USART1_GPIO_PINS, USART1_GPIO_CFG, NULL); usart1_cb = cb; irq_number = USART1_IRQn; irq_priority = USART1_IRQ_PRIORITY; // Configure USART speed u->BRR = sysclks.apb2_freq / baud; #else return -1; // USART1 not enabled #endif } /*Reset usart conf */ u->CR1&=~(1<<12); //nb de bit par data raz u->CR1&=~(7<<8); //parit\u00e9 raz u->CR2&=~(3<<12); //bit stop u->GTPR = 0; u->CR3 = 0; /*conf \u00e0 partir mode */ /* mode = b10-b9-b8-x-x-b5-b4-x-x-x-b0 b0 = 8/9 bits dans CR1 b12 b5/b4 = nb bit stop dans CR2 b13/b12 b10/b9/b8 = parit\u00e9 , 10 controle parit\u00e9 (1 activ\u00e9/0 d\u00e9sactiv\u00e9), 9 type parit\u00e9 (Odd/Even) , 8 PEIE parity Error interrupt enable */ u->CR1 |=((mode & 0x1)<<12) | (mode & 0x700) | (3<<2) | (1<<13); //conf + tx/rx activ\u00e9 + usart enable u->CR2 |=((mode & 0x30)<<8); //bit stop positionn\u00e9 en b12/b13 de CR2 // Setup NVIC if (cb) { /* A COMPLETER */ NVIC_SetPriority(irq_number, irq_priority); NVIC_EnableIRQ(irq_number); u->CR1 |= (1<<5);// Receiver Not Empty Interrupt Enable } }","title":"UART1 Initialization and Callback"},{"location":"Wireless/#test","text":"In the main file, we need to add a callback function to handle communication via Zigbee: static void on_zigbee_command_received(char c) { command = c; uart_printf(UART_TO_USE, \"\\r\\nZigbee command received: %c\\r\\n\", c); } // Initialization required uart_init(_USART2, 115200, UART_8N1, on_command_received); uart_init(_USART1, 115200, UART_8N1, on_zigbee_command_received); Now that we have completed these steps, we can verify if everything functions correctly by conducting the same test mentioned in the section above, but using the 'tty/USB0' port.","title":"Test"},{"location":"Wireless/#bluetooth-low-energy-ble","text":"Bluetooth Low Energy (BLE) is a wireless communication technology designed for short-range communication with minimal power consumption. It is commonly used in applications such as wearable devices, smart home products, and health monitoring systems.","title":"Bluetooth Low Energy (BLE)"},{"location":"Wireless/#hardware-requirements","text":"X-NUCLEO-IDB05A2 : This is a Bluetooth Low Energy (BLE) expansion board based on the SPBTLE-RF module. It can be used with STM32 Nucleo development boards to add BLE functionality to your projects.","title":"Hardware Requirements"},{"location":"Wireless/#configuring-our-services","text":"","title":"Configuring Our Services"},{"location":"Wireless/#temperature-service","text":"To create a BLE service for temperature data, we use the characteristic UUID 0x2A6E . // TEMPERATURE CHAR : 0x2A6E primary_short_uuid[0] = 0x6E; primary_short_uuid[1] = 0x2A; ret = aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_16, primary_short_uuid, 2, CHAR_PROP_NOTIFY | CHAR_PROP_READ, ATTR_PERMISSION_NONE, GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP, 16, 0, &TemperatureCharHandle); if (ret != BLE_STATUS_SUCCESS) { goto fail; } HAL_Delay(100);","title":"Temperature Service"},{"location":"Wireless/#color-temperature-service","text":"To create a BLE service for color temperature data, we use the characteristic UUID 0x2A63. // Color temp 0x2A63 primary_short_uuid[0] = 0x63; primary_short_uuid[1] = 0x2A; ret = aci_gatt_add_char(HWServW2STHandle, UUID_TYPE_16, primary_short_uuid, 2, CHAR_PROP_NOTIFY | CHAR_PROP_READ, ATTR_PERMISSION_NONE, GATT_NOTIFY_READ_REQ_AND_WAIT_FOR_APPL_RESP, 16, 0, &TempColorCharHandle); if (ret != BLE_STATUS_SUCCESS) { goto fail; } HAL_Delay(100); return BLE_STATUS_SUCCESS; fail: return BLE_STATUS_ERROR;","title":"Color Temperature Service"},{"location":"Wireless/#updating-environmental-data","text":"The function Environmental_Update updates the temperature and color temperature values tBleStatus Environmental_Update(int16_t Temp, int16_t color_temp) { tBleStatus ret; uint8_t buff_Temp[2]; uint8_t buff_color_temp[2]; STORE_LE_16(buff_Temp, Temp); ret = aci_gatt_update_char_value(HWServW2STHandle, TemperatureCharHandle, 0, 2, buff_Temp); if (ret != BLE_STATUS_SUCCESS) { return BLE_STATUS_ERROR; } STORE_LE_16(buff_color_temp, color_temp); ret = aci_gatt_update_char_value(HWServW2STHandle, TempColorCharHandle, 0, 2, buff_color_temp); if (ret != BLE_STATUS_SUCCESS) { return BLE_STATUS_ERROR; } return BLE_STATUS_SUCCESS; }","title":"Updating Environmental Data"},{"location":"Wireless/#sending-data","text":"After receiving a notification, you can send the updated values void SendEnvironmentalData(void) { static float temperature, humidity; uint16_t red, green, blue, clear, color_temp; float x, y; int32_t TempToSend = 0; int32_t decPart, intPart; int16_t ret; ret = sht4x_measure_blocking_read(&temperature, &humidity); tcs34725_read_color(&red, &green, &blue, &clear); color_temp = calculateColorTemperature(red, green, blue, &x, &y); MCR_BLUEMS_F2I_1D(temperature, intPart, decPart); TempToSend = intPart * 10 + decPart; printf(\"\\r\\ntemperature: %d.%d C\", intPart, decPart); printf(\"\\r\\ntemperature en kelvin: %d K\", color_temp); Environmental_Update(TempToSend, color_temp); HAL_Delay(1000); }","title":"Sending Data"},{"location":"Wireless/#summary","text":"In this project, we successfully set up a Bluetooth Low Energy (BLE) communication system using the X-NUCLEO-IDB05A2 expansion board. We configured services for both temperature and color temperature data, updated these values, and sent the data using BLE notifications.","title":"Summary"}]}